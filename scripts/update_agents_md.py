import ast
import os
import sys
from pathlib import Path

# --- Static Documentation Sections ---

HEADER = """---
Version: 2.0
Last Updated: {date}
Python: 3.10+
Gradio: 6.x
SAM3: Via submodule
---

# Developer Guidelines & Agent Memory

> **âš ï¸ AUTO-GENERATED FILE**: This file is generated by `scripts/update_agents_md.py`.
> Manual edits to the code skeletons will be overwritten.
> To update the guidelines, edit the static sections in the script.

**âš ï¸ CRITICAL**: Read this before starting any task.

ðŸ”´ CRITICAL | ðŸŸ¡ WARNING | ðŸŸ¢ BEST PRACTICE
"""

QUICK_START = """
## 1. Quick Start Guide

### 5-Minute Setup
1. **Clone & Submodules**: `git submodule update --init --recursive`
2. **Environment**: `python3 -m venv venv && source venv/bin/activate`
3. **Dependencies**: `pip install -r requirements.txt` (Installs SAM3 via submodule)
4. **Run App**: `python app.py`

### Essential Commands
- **Test Backend**: `python -m pytest tests/`
- **Test E2E**: `pytest tests/e2e/` (Requires Playwright)
- **Lint/Check**: `.claude/commands/validate.md` (if available)

### Directory Structure
- `app.py`: Entry point.
- `core/`: Business logic (pipelines, config, db).
- `ui/`: Gradio interface components.
- `tests/`: Unit and E2E tests.
- `SAM3_repo/`: **Read-only** submodule.
"""

CRITICAL_RULES = """
## 2. Critical Rules

### ðŸ”´ CRITICAL (Must Follow)
- **NEVER** edit files in `SAM3_repo` or `Grounded-SAM-2`. Treat as external libraries.
- **ALWAYS** match Gradio event handler return values count to the `outputs` list. Mismatches crash the app silently.
- **NEVER** use `@lru_cache` on functions taking the `Config` object (it's unhashable). Use `model_registry.get_or_load`.
- **ALWAYS** use `pathlib.Path`, never `os.path`.
- **ALWAYS** mock external dependencies (SAM3, Torch) in unit tests.

### ðŸŸ¡ WARNING (Potential Bugs)
- **Check Masks**: Verify masks exist on disk before export/processing.
- **Thread Safety**: MediaPipe objects are not thread-safe. Use thread-local storage or one instance per thread.
- **Gradio State**: Do not store locks or file handles in `gr.State`.

### ðŸŸ¢ BEST PRACTICE
- **Refactoring**: Move logic from `app.py` to `core/`.
- **Typing**: Use Pydantic models (`core/events.py`) instead of untyped dicts.
"""

ARCHITECTURE = """
## 3. Architecture Overview

### Data Flow
`UI (Gradio)` â†’ `Event Object (Pydantic)` â†’ `Pipeline (Core)` â†’ `Database/Files`

### Component Relationship
```
[app.py] (UI Assembly)
   â”‚
   â”œâ”€ [core/config.py] (Settings)
   â”œâ”€ [core/managers.py] (ModelRegistry, ThumbnailManager)
   â””â”€ [core/pipelines.py] (Logic)
         â”‚
         â”œâ”€ ExtractionPipeline (FFmpeg)
         â”œâ”€ AnalysisPipeline (SAM3, InsightFace)
         â””â”€ ExportPipeline (Filtering, Rendering)
```

### State Management
- **Session State**: `gr.State` stores mutable data (scene lists, paths).
- **Global State**: `ModelRegistry` (Singleton-like) manages heavy models.
- **Persistence**: `metadata.db` (SQLite) for frame data; `json` for configs.
"""

DEVELOPMENT_WORKFLOWS = """
## 5. Development Workflows

### Bug Fix Workflow
1. **Reproduce**: Create a test case in `tests/test_reproduce_issue.py`.
2. **Log**: Use `logger.debug()` to trace execution.
3. **Fix**: Implement fix in `core/` or `ui/`.
4. **Verify**: Run `python -m pytest tests/`.
5. **Clean**: Remove temporary test files.

### Adding a New Metric
1. **Config**: Add default thresholds to `Config` in `core/config.py`.
2. **Extraction**: Update `_extract_metric_arrays()` in `core/filtering.py`.
3. **UI**: Add slider in `ui/app_ui.py` inside `_create_filtering_tab`.
4. **Analysis**: Update `calculate_quality_metrics` in `core/models.py`.
"""

TESTING_GUIDE = """
## 6. Testing & Mocking Guide

### When to Mock
- **File I/O**: Patch `pathlib.Path.exists`, `open`.
- **ML Models**: Always mock `SAM3Wrapper`, `FaceAnalysis`, `FaceLandmarker`.
- **Submodules**: Mock `sam3` package to avoid import errors.

### Common Patterns
```python
# Mocking a class method
@patch("core.managers.ModelRegistry.get_tracker")
def test_tracker(mock_get, app_ui):
    mock_get.return_value = MagicMock()
    ...
```

### E2E vs Unit
- **Unit**: Fast, mocks everything. Run pre-commit.
- **E2E**: Slower, uses `mock_app.py` to simulate backend. Checks UI flows.
"""

CONFIG_REF = """
## 7. Configuration Reference

See `core/config.py` for full list.

| Category | Key Fields | Default |
|----------|------------|---------|
| **Paths** | `logs_dir`, `models_dir`, `downloads_dir` | `logs`, `models`, `downloads` |
| **Models** | `face_model_name`, `tracker_model_name` | `buffalo_l`, `sam3` |
| **perf** | `analysis_default_workers` | 4 |
| **UI** | `default_thumb_megapixels` | 0.5 |
"""

TROUBLESHOOTING = """
## 8. Troubleshooting

### Error: "CUDA out of memory"
- **Where**: SAM3 initialization, NIQE metric.
- **Fix**: Set `model_registry.runtime_device_override = 'cpu'`.
- **Prevention**: Call `cleanup_models()` between sessions.

### Error: "ModuleNotFoundError: sam3"
- **Cause**: Submodule not initialized.
- **Fix**: `git submodule update --init --recursive`.
- **Check**: Verify `SAM3_repo/` exists and has files.

### Error: "ValueError: ... is not in list" (Gradio)
- **Cause**: `gr.Radio` or `gr.Dropdown` value updated to something not in `choices`.
- **Fix**: Update `choices` list *before* setting `value`.
"""

PERFORMANCE = """
## 9. Performance & Memory

- **SAM3**: Requires ~8GB VRAM. Falls back to CPU (slow).
- **Thumbnails**: Cached in RAM (`ThumbnailManager`). LRU eviction.
- **Batch Processing**: Uses `ThreadPoolExecutor`. Limit workers in Config if OOM occurs.
"""

API_REF = """
## 10. API Quick Reference

### Key Functions
- `execute_extraction(event: ExtractionEvent) -> Generator`
- `execute_pre_analysis(event: PreAnalysisEvent) -> Generator`
- `execute_propagation(event: PropagationEvent) -> Generator`

### Event Models
- `ExtractionEvent`: Source path, method (interval/scene).
- `PreAnalysisEvent`: Analysis params, seed strategy.
- `PropagationEvent`: List of scenes to process.
"""

GIT_DEPLOY = """
## 11. Git & Deployment

- **Submodules**: Always update recursive.
- **Requirements**: `requirements.txt` is root.
- **Validation**: Verify model downloads with SHA256.
"""

# --- AST Parser for Section 4 ---

def process_node(node, indent=0):
    lines = []
    prefix = " " * indent

    # Decorators
    for decorator in node.decorator_list:
        lines.append(f"{prefix}@{ast.unparse(decorator)}")

    # Definition
    if isinstance(node, ast.ClassDef):
        bases = [ast.unparse(b) for b in node.bases]
        base_str = f"({', '.join(bases)})" if bases else ""
        lines.append(f"{prefix}class {node.name}{base_str}:")
    elif isinstance(node, ast.FunctionDef):
        args = ast.unparse(node.args)
        returns = f" -> {ast.unparse(node.returns)}" if node.returns else ""
        lines.append(f"{prefix}def {node.name}({args}){returns}:")
    elif isinstance(node, ast.AsyncFunctionDef):
        args = ast.unparse(node.args)
        returns = f" -> {ast.unparse(node.returns)}" if node.returns else ""
        lines.append(f"{prefix}async def {node.name}({args}){returns}:")

    # Docstring
    docstring = ast.get_docstring(node)
    if docstring:
        doc_lines = docstring.strip().split('\n')
        lines.append(f'{prefix}    """')
        for dl in doc_lines:
            lines.append(f"{prefix}    {dl.strip()}")
        lines.append(f'{prefix}    """')

    # Body Summary
    if isinstance(node, ast.ClassDef):
        has_content = False
        for child in node.body:
            if isinstance(child, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                has_content = True
                lines.extend(process_node(child, indent + 4))
            elif isinstance(child, ast.Assign):
                # Class attributes (simple constants)
                try:
                    lines.append(f"{prefix}    {ast.unparse(child)}")
                    has_content = True
                except: pass

        if not has_content:
            lines.append(f"{prefix}    ...")
    else:
        # Function body -> Ellipsis
        lines.append(f"{prefix}    ...")

    return lines

def parse_file_to_skeleton(file_path):
    try:
        code = file_path.read_text(encoding='utf-8')
        tree = ast.parse(code)
    except (SyntaxError, UnicodeDecodeError) as e:
        return f"# Error parsing file: {e}"

    lines = []

    # Docstring
    docstring = ast.get_docstring(tree)
    if docstring:
        lines.append(f'"""\n{docstring}\n"""\n')

    # Imports
    imports = []
    for node in tree.body:
        if isinstance(node, (ast.Import, ast.ImportFrom)):
            imports.append(ast.unparse(node))

    if imports:
        lines.extend(imports)
        lines.append("")

    for node in tree.body:
        if isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.AsyncFunctionDef)):
            lines.extend(process_node(node))
            lines.append("")
        elif isinstance(node, ast.Assign):
            # Top level constants
            lines.append(ast.unparse(node))

    return "\n".join(lines)

def generate_skeleton_section(root_dir):
    output = ["## 4. Code Skeleton Reference\n"]

    exclude_dirs = {'.git', 'venv', '__pycache__', 'SAM3_repo', 'Grounded-SAM-2', '.claude', '.jules', 'dry-run-assets', 'logs', 'downloads', 'models', 'node_modules', '.github', 'init_logs'}

    files = []
    for root, dirs, filenames in os.walk(root_dir):
        dirs[:] = [d for d in dirs if d not in exclude_dirs]
        for name in filenames:
            if name.endswith(".py") and name != os.path.basename(__file__):
                files.append(Path(root) / name)

    files.sort()

    for file_path in files:
        rel_path = file_path.relative_to(root_dir)
        output.append(f"### `ðŸ“„ {rel_path}`\n")
        output.append("```python")
        skeleton = parse_file_to_skeleton(file_path)
        output.append(skeleton)
        output.append("```\n")

    return "\n".join(output)

def main():
    import datetime
    current_date = datetime.date.today().isoformat()

    # Generate Skeleton Section
    print("Generating code skeletons...")
    skeleton_section = generate_skeleton_section(".")

    # Assemble Content
    full_content = [
        HEADER.format(date=current_date),
        QUICK_START,
        CRITICAL_RULES,
        ARCHITECTURE,
        skeleton_section,
        DEVELOPMENT_WORKFLOWS,
        TESTING_GUIDE,
        CONFIG_REF,
        TROUBLESHOOTING,
        PERFORMANCE,
        API_REF,
        GIT_DEPLOY
    ]

    # Write AGENTS.md
    output_path = Path("AGENTS.md")
    output_path.write_text("\n".join(full_content), encoding="utf-8")
    print(f"Successfully updated {output_path}")

    # Cleanup old references
    ref_file = Path("AGENTS_CODE_REFERENCE.md")
    if ref_file.exists():
        ref_file.unlink()
        print(f"Removed deprecated {ref_file}")

if __name__ == "__main__":
    main()
